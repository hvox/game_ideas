#!/usr/bin/env python3
"""
Prints detailed plan how to build a factory of a specified material.

Usage: {script} [options] NAME [IPM]

Arguments:
    NAME - Material to be produced.
    IPM - Items per minute to be produced.

Options:
    -h, --help
        Show this screen and exit.

    --verbose
        Raise verbosity level.
"""
import math
import sys
from contextlib import suppress
from difflib import get_close_matches
from fractions import Fraction
from graphlib import TopologicalSorter
from pathlib import Path

from materials_61774 import Material

# TODO: delete or reimplement
IGNORED_MATERIALS = {
    " aboba ? ",
    # "advanced-circuit",
    # "electronic-circuit",
    # "plastic-bar",
    # "processing-unit",
    # "sulfuric-acid",
}

MATERIALS = Material.load_materials()

COLLECTIONS = {
    "science-packs": {
        "automation-science-pack": Fraction(1),
        "logistic-science-pack": Fraction(1),
        "chemical-science-pack": Fraction(1),
        "military-science-pack": Fraction(1),
        "production-science-pack": Fraction(1),
        "utility-science-pack": Fraction(1),
        "space-science-pack": Fraction(1),
    },
    "rocket-silo-research": {
        "automation-science-pack": Fraction(5750),
        "logistic-science-pack": Fraction(5565),
        "chemical-science-pack": Fraction(3650),
        "production-science-pack": Fraction(1600),
        "utility-science-pack": Fraction(1300),
    },
}


def show_plan(target_material: str, target_ipm: Fraction):
    if target_material in COLLECTIONS:
        targets = {mat: ipm * target_ipm for mat, ipm in COLLECTIONS[target_material].items()}
    else:
        targets = {target_material: target_ipm}
    total = dict_sum(MATERIALS[mat].total_cost(ipm) for mat, ipm in targets.items())
    for material, amount in reversed(total.items()):
        amount_str = math.ceil(10 * amount) / 10 if amount % 1 else int(amount)
        line = f"{float(amount/material.items_per_lane):9.2f} {material.name:23} IPM={amount_str}"
        if material:
            buildings = math.ceil(amount / 60 * material.buildings * 10) / 10
            buildings = int(buildings) if buildings % 1 == 0 else buildings
            suffix = f" [{buildings}]"
            suffix += " <- " + ", ".join(
                f"\x1b[9{MATERIALS[ingr].color}m{ingr}:{float(amount*x):.1f}"
                for ingr, x in material.ingredients.items()
            )
        else:
            suffix = "\x1b[0m <- source"
        line += " " * (43 - len(line)) + suffix
        print(f"\x1b[9{material.color}m" + line + "\x1b[0m")
    print()


def main(script_name: str, *script_args: str):
    doc = __doc__.format(script=Path(script_name).name)
    args = __import__("docopt").docopt(doc, script_args)
    setattr(debug, "enabled", args["--verbose"])
    debug(f"Running with arguments {dict(args)!r}")
    target = args["NAME"]
    target_ipm = Fraction(args["IPM"] or "900")
    available_targets = list(MATERIALS) + list(COLLECTIONS)
    if target not in available_targets:
        print(f"\x1b[91mERROR:\x1b[0m I have no idea what \x1b[91m{target}\x1b[0m is!")
        prefixes = ["Did you mean", "or maybe", "or"]
        for i, suggestion in enumerate(get_close_matches(target, available_targets, 3, 0.5)):
            print(f"       {prefixes[i]} \x1b[92m{suggestion}\x1b[0m?")
        exit(1)
    show_plan(target, target_ipm)


def to_continue(msg: str = "Press enter to continue... "):
    with suppress(EOFError):
        return input(msg) in ("", "\r")
    print()
    return True


def dict_sum(*dicts):
    if len(dicts) == 1 and not hasattr(dicts[0], "items"):
        dicts = dicts[0]
    total = {}
    for dict in dicts:
        for key, value in dict.items():
            total[key] = value if key not in total else total[key] + value
    return total


def debug(*objects: object, sep: str = " "):
    if getattr(debug, "enabled", False):
        print(sep.join(map(str, objects)))


if __name__ == "__main__":
    with suppress(KeyboardInterrupt):
        main(sys.argv[0], *sys.argv[1:])
