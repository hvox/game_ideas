#!/usr/bin/env python3
"""
Prints detailed plan how to build a factory of a specified material.

Usage: {script} [options] NAME [IPM]

Arguments:
    NAME - Material to be produced.
    IPM - Items per minute to be produced.

Options:
    -h, --help
        Show this screen and exit.

    --verbose
        Raise verbosity level.
"""
import math
import sys
from contextlib import suppress
from difflib import get_close_matches
from fractions import Fraction
from itertools import chain, combinations
from pathlib import Path

from materials_61774 import Material

# TODO: delete or reimplement
IGNORED_MATERIALS = {
    " aboba ? ",
    # "advanced-circuit",
    # "electronic-circuit",
    # "plastic-bar",
    # "processing-unit",
    # "sulfuric-acid",
}

MATERIALS = Material.load_materials()
COAL, IRON, COPPER, PLASTIC, GREEN, RED, BLUE = Material.load_the_boys()

COLLECTIONS = {
    "science-packs": {
        "automation-science-pack": Fraction(1),
        "logistic-science-pack": Fraction(1),
        "chemical-science-pack": Fraction(1),
        "military-science-pack": Fraction(1),
        "production-science-pack": Fraction(1),
        "utility-science-pack": Fraction(1),
        "space-science-pack": Fraction(1),
    },
    "rocket-silo-research": {
        "automation-science-pack": Fraction(5750),
        "logistic-science-pack": Fraction(5565),
        "chemical-science-pack": Fraction(3650),
        "production-science-pack": Fraction(1600),
        "utility-science-pack": Fraction(1300),
    },
}


def show_plan(target_material: str, target_ipm: Fraction):
    if target_material in COLLECTIONS:
        targets = {mat: ipm * target_ipm for mat, ipm in COLLECTIONS[target_material].items()}
    else:
        targets = {target_material: target_ipm}
    total = dict_sum(
        MATERIALS[mat].total_cost(ipm, (lambda material: material.name in IGNORED_MATERIALS))
        for mat, ipm in targets.items()
    )
    for material, amount in reversed(total.items()):
        amount_str = math.ceil(10 * amount) / 10 if amount % 1 else int(amount)
        line = f"{float(amount/material.items_per_lane):9.2f} {material.name:23} IPM={amount_str}"
        if material and material.name not in IGNORED_MATERIALS:
            buildings = math.ceil(amount / 60 * material.buildings * 10) / 10
            buildings = int(buildings) if buildings % 1 == 0 else buildings
            suffix = f" [{buildings}]"
            suffix += " <- " + ", ".join(
                f"\x1b[{MATERIALS[ingr].color}m{ingr}:{float(amount*x):.1f}\x1b[0m"
                for ingr, x in material.ingredients.items()
            )
        else:
            suffix = "\x1b[0m <- source"
        line += " " * (43 - len(line)) + suffix
        print(f"\x1b[{material.color}m" + line + "\x1b[0m")
    print()


def show_nice_sizes(target_material: Material):
    def ignored(material: Material):
        return material.name != target_material.name and material.name == "sulfuric-acid"

    def get_nice_inputs(original_total: dict):
        for inputs in subsets([BLUE, RED, GREEN]):
            if target_material in inputs:
                continue
            total = original_total
            result = {}
            inputs += (IRON, COPPER, PLASTIC)
            for inp in (inp for inp in inputs if inp in total):
                result[inp] = total[inp]
                total = dict_substract(total, inp.total_cost(total[inp], ignored))
            if all(x % 900 == 0 or x % 900 > 886.5 for inp, x in result.items()):
                return result
        return None

    nice_sizes = []
    for ipm in map(Fraction, (900, 1800, 3600, 2700)):
        total = target_material.total_cost(ipm, ignored)
        if inputs := get_nice_inputs(total):
            nice_sizes.append((ipm, inputs))
            break
    total = target_material.total_cost(1, ignored)
    cost = sum((total.get(x, Fraction(0)) for x in [IRON, COPPER, PLASTIC]), Fraction(0))
    for i in range(1, round(12 * cost) + 1):
        ipm = i * 900 / cost
        total = target_material.total_cost(ipm, ignored)
        if inputs := get_nice_inputs(total):
            nice_sizes.append((ipm, inputs))
            break
    if not nice_sizes:
        print("\x1b[91mFAILURE: No nice sizes found...\x1b[0m")
        total = target_material.total_cost(900, ignored)
        inputs = [COAL, IRON, COPPER, PLASTIC]
        nice_sizes = [(900, {inp: total[inp] for inp in inputs if inp in total})]
    ipm_len = max(len(str(ipm)) for ipm, _ in nice_sizes)
    belts_len = max(len(f2s(ipm / 900)) for ipm, _ in nice_sizes)
    for i, (ipm, inputs) in enumerate(nice_sizes):
        if any((ipm, inputs) == size for size in nice_sizes[:i]):
            continue
        belts = f2s(ipm / 900)
        direct = {mat: x * ipm for mat, x in target_material}
        direct_inputs_str = " ".join(f"\x1b[{inp.color}m{inp}:{f2s(x/900)}\x1b[0m" for inp, x in direct.items())
        inputs_str = " ".join(f"\x1b[{inp.color}m{inp}:{f2s(x/900)}\x1b[0m" for inp, x in inputs.items())
        print(
            f"\x1b[{target_material.color}m"
            # f"IPM={ipm:{ipm_len}<}"
            f"     {target_material.name}:{belts:{belts_len}}\x1b[0m"
            # f" <= {direct_inputs_str}"
            f" <= {inputs_str}"
        )


def main(script_name: str, *script_args: str):
    doc = __doc__.format(script=Path(script_name).name)
    args = __import__("docopt").docopt(doc, script_args)
    setattr(debug, "enabled", args["--verbose"])
    debug(f"Running with arguments {dict(args)!r}")
    target = args["NAME"]
    available_targets = list(MATERIALS) + list(COLLECTIONS)
    if target not in available_targets:
        print(f"\x1b[91mERROR:\x1b[0m I have no idea what \x1b[91m{target}\x1b[0m is!")
        prefixes = ["Did you mean", "or maybe", "or"]
        for i, suggestion in enumerate(get_close_matches(target, available_targets, 3, 0.5)):
            print(f"       {prefixes[i]} \x1b[92m{suggestion}\x1b[0m?")
        exit(1)
    if args["IPM"]:
        show_plan(target, Fraction(args["IPM"]))
    else:
        show_nice_sizes(MATERIALS[target])


def to_continue(msg: str = "Press enter to continue... "):
    with suppress(EOFError):
        return input(msg) in ("", "\r")
    print()
    return True


def dict_sum(*dicts):
    if len(dicts) == 1 and not hasattr(dicts[0], "items"):
        dicts = dicts[0]
    total = {}
    for dict in dicts:
        for key, value in dict.items():
            total[key] = value if key not in total else total[key] + value
    return total


def dict_substract(dict1, dict2):
    total = dict(dict1)
    for key, value in dict2.items():
        total[key] -= value
    return total


def subsets(items):
    return chain(*(combinations(items, r) for r in range(len(items) + 1)))


def f2s(number: Fraction) -> str:
    return str(number) if number % 1 == 0 else str(math.ceil(number * 100) / 100)


def debug(*objects: object, sep: str = " "):
    if getattr(debug, "enabled", False):
        print(sep.join(map(str, objects)))


if __name__ == "__main__":
    with suppress(KeyboardInterrupt):
        main(sys.argv[0], *sys.argv[1:])
